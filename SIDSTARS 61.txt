import os
import sys
import sqlite3
import re
import json
import time
import math # Adicionado para cálculos de distância
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget,
    QPushButton, QFileDialog, QLabel, QLineEdit, QTableWidget,
    QTableWidgetItem, QHeaderView, QSplitter, QStatusBar, QDialog,
    QListWidget, QListWidgetItem, QInputDialog, QMessageBox, QFormLayout,
    QTextEdit, QDialogButtonBox, QMenu
)
from PyQt6.QtGui import QAction, QShortcut, QKeySequence, QClipboard, QIcon, QActionGroup
from PyQt6.QtCore import Qt, QTimer, QPoint, QSize, QRect

# Importar bibliotecas para verificar processos em primeiro plano
try:
    import win32gui
    import win32process
    import psutil
    process_tracking_available = True
except ImportError:
    process_tracking_available = False

# --- Função de Cálculo de Distância Haversine ---
def calculate_haversine(lat1, lon1, lat2, lon2):
    """Calcula a distância great-circle entre dois pontos em NM."""
    # Retorna 0.0 se alguma coordenada for None ou inválida (ex: 0.0)
    # A verificação de None é crucial
    if None in [lat1, lon1, lat2, lon2] or not all([lat1, lon1, lat2, lon2]):
        return 0.0

    try:
        # Converte para float explicitamente para evitar erros com tipos inesperados
        lat1, lon1, lat2, lon2 = map(float, [lat1, lon1, lat2, lon2])
    except (ValueError, TypeError):
        print(f"Erro de conversão em Haversine: {(lat1, lon1, lat2, lon2)}")
        return 0.0 # Retorna 0 se a conversão falhar


    R_NM = 3440.065 # Raio médio da Terra em milhas náuticas

    lat1_rad = math.radians(lat1)
    lon1_rad = math.radians(lon1)
    lat2_rad = math.radians(lat2)
    lon2_rad = math.radians(lon2)

    dlon = lon2_rad - lon1_rad
    dlat = lat2_rad - lat1_rad

    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2

    # Verificação para evitar erro de domínio em math.sqrt
    if a < 0: a = 0
    if a > 1: a = 1

    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))

    distance = R_NM * c
    return distance

# Classe para o botão de âncora
class AnchorButton(QWidget):
    def __init__(self, parent_window=None, anchor_mode="Global"):
        # Criamos sem relacionamento de pai para evitar minimização automática
        super().__init__(None)
        self.parent_window = parent_window
        self.anchor_mode = anchor_mode  # Guarda o modo da âncora (Global ou Aurora)

        self.setWindowFlags(Qt.WindowType.WindowStaysOnTopHint | Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)

        # Tamanho fixo para o botão
        self.setFixedSize(40, 40)

        # Configurar o layout e o botão
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self.anchor_btn = QPushButton("⚓", self)
        self.anchor_btn.setFixedSize(40, 40)
        # O estilo é aplicado dinamicamente com base no tema da janela principal
        # self.anchor_btn.setStyleSheet(...) # Removido daqui
        self.anchor_btn.clicked.connect(self.toggle_main_window)

        layout.addWidget(self.anchor_btn)

        # Variáveis para controlar o arrastar
        self.dragging = False
        self.offset = QPoint()

        # Armazena se a janela está minimizada
        self.window_minimized = False

        # Timer para verificar o processo em primeiro plano (modo Aurora)
        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_foreground_process)

        # Iniciar o timer se o modo for Aurora
        if self.anchor_mode == "Aurora" and process_tracking_available:
            self.check_timer.start(500)  # Verificar a cada 500ms

        # Aplicar estilo inicial baseado no tema da janela principal
        if self.parent_window:
            if self.parent_window.dark_theme_enabled:
                self.apply_dark_style()
            else:
                self.apply_light_style()

    def toggle_main_window(self):
        # Nova implementação - a âncora SEMPRE restaura a janela principal
        if self.parent_window:
            # Sempre restaurar, independentemente do estado atual
            self.parent_window.showNormal()
            self.parent_window.raise_()
            self.parent_window.activateWindow()
            self.parent_window.focus_search_input()
            self.window_minimized = False  # Atualizar o estado interno

    def check_foreground_process(self):
        """Verifica se o processo em primeiro plano é o Aurora.exe, python.exe ou a própria aplicação"""
        if not process_tracking_available or self.anchor_mode != "Aurora":
            return

        # Não verificar se estiver arrastando para evitar o piscar
        if self.dragging:
            return

        try:
            # Obter janela em primeiro plano
            hwnd = win32gui.GetForegroundWindow()
            _, foreground_pid = win32process.GetWindowThreadProcessId(hwnd)

            # Obter o PID do nosso próprio processo
            current_pid = os.getpid()

            try:
                process = psutil.Process(foreground_pid)
                process_name = process.name().lower()

                # Verificar se o processo em primeiro plano é:
                # 1. Aurora.exe, ou
                # 2. python.exe, ou
                # 3. O mesmo processo da nossa aplicação (comparando PIDs)
                show_anchor = ("aurora.exe" in process_name or
                            "python.exe" in process_name or
                            foreground_pid == current_pid)

                if show_anchor:
                    if not self.isVisible():
                        self.show()
                else:
                    # Esconder a âncora quando outros aplicativos estiverem em primeiro plano
                    if self.isVisible():
                        self.hide()

                    # NÃO minimizar automaticamente a janela principal

            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        except Exception as e:
            print(f"Erro ao verificar processo em primeiro plano: {e}")

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.RightButton:
            self.dragging = True
            # Armazenar apenas a posição do clique
            self.offset = event.position().toPoint()
            # Impedir que o clique seja tratado como um clique de botão
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self.dragging:
            # Calcular nova posição usando a posição global do mouse
            global_pos = event.globalPosition().toPoint()
            self.move(global_pos - self.offset)
            event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.RightButton:
            self.dragging = False
            event.accept()
        else:
            super().mouseReleaseEvent(event)

    def set_anchor_mode(self, mode):
        """Atualiza o modo da âncora"""
        self.anchor_mode = mode

        # Iniciar ou parar o timer de verificação baseado no modo
        if self.anchor_mode == "Aurora" and process_tracking_available:
            if not self.check_timer.isActive():
                self.check_timer.start(500)
            # Verificar imediatamente
            self.check_foreground_process()
        else:
            if self.check_timer.isActive():
                self.check_timer.stop()
            # No modo Global, sempre mostrar
            if self.isVisible(): # Evita chamar show() desnecessariamente se já estiver visível
                pass
            else:
                self.show()

    # Funções para aplicar estilo
    def apply_dark_style(self):
        self.anchor_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(60, 60, 70, 180);
                color: white;
                border-radius: 20px;
                font-size: 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: rgba(80, 80, 90, 200);
            }
        """)

    def apply_light_style(self):
        # Usar o mesmo estilo para ambos os temas, pois é translúcido
         self.anchor_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(60, 60, 70, 180);
                color: white;
                border-radius: 20px;
                font-size: 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: rgba(80, 80, 90, 200);
            }
        """)

# Diálogo para gerenciar perfis de aeroportos
class ProfileManagerDialog(QDialog):
    def __init__(self, parent=None, profiles=None):
        super().__init__(parent)
        self.setWindowTitle("Gerenciador de Perfis de Aeroportos")
        self.setMinimumSize(600, 400)

        # Receber os perfis existentes (fazer cópia para evitar modificar original)
        self.profiles = profiles.copy() if profiles else {}

        # Configurar o layout
        main_layout = QVBoxLayout(self)

        # Lista de perfis disponíveis
        profile_layout = QHBoxLayout()

        # Layout esquerdo - lista de perfis
        left_layout = QVBoxLayout()
        left_layout.addWidget(QLabel("Perfis Disponíveis:"))

        self.profile_list = QListWidget()
        self.profile_list.currentItemChanged.connect(self.on_profile_selected)
        left_layout.addWidget(self.profile_list)

        # Botões para gerenciar os perfis
        profile_buttons = QHBoxLayout()
        self.add_button = QPushButton("Adicionar")
        self.add_button.clicked.connect(self.add_profile)
        self.rename_button = QPushButton("Renomear")
        self.rename_button.clicked.connect(self.rename_profile)
        self.delete_button = QPushButton("Excluir")
        self.delete_button.clicked.connect(self.delete_profile)

        profile_buttons.addWidget(self.add_button)
        profile_buttons.addWidget(self.rename_button)
        profile_buttons.addWidget(self.delete_button)
        left_layout.addLayout(profile_buttons)

        # Layout direito - edição de aeroportos do perfil
        right_layout = QVBoxLayout()
        right_layout.addWidget(QLabel("Aeroportos no Perfil:"))

        self.airports_edit = QTextEdit()
        self.airports_edit.setPlaceholderText("Digite os códigos de aeroportos separados por vírgula (ex: SBGR, SBSP, SBRJ)")
        right_layout.addWidget(self.airports_edit)

        # Adicionar layouts ao layout principal
        profile_layout.addLayout(left_layout, 1)
        profile_layout.addLayout(right_layout, 2)

        main_layout.addLayout(profile_layout)

        # Botões de diálogo
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        main_layout.addWidget(buttons)

        # Preencher a lista de perfis
        self.populate_profile_list()

        # Desabilitar botões de edição até que um perfil seja selecionado
        self.rename_button.setEnabled(False)
        self.delete_button.setEnabled(False)
        self.airports_edit.setEnabled(False)

    # Sobrescrever o método accept para salvar automaticamente as alterações
    def accept(self):
        # Salvar quaisquer alterações pendentes antes de aceitar o diálogo
        current_item = self.profile_list.currentItem()
        if current_item:
            profile_name = current_item.data(Qt.ItemDataRole.UserRole)
            # Verificar se o perfil ainda existe (pode ter sido excluído)
            if profile_name in self.profiles:
                airports_text = self.airports_edit.toPlainText().strip()
                # Atualizar o perfil com o texto atual
                self.profiles[profile_name] = airports_text

        # Chamar o método accept da classe pai
        super().accept()

    def populate_profile_list(self):
        """Preenche a lista de perfis disponíveis."""
        self.profile_list.clear()
        for profile_name in sorted(self.profiles.keys()):
            # Não exibir o perfil "Manual" na lista de perfis gerenciáveis
            if profile_name != "Manual":
                item = QListWidgetItem(profile_name)
                # Armazenar o nome do perfil como dado do item
                item.setData(Qt.ItemDataRole.UserRole, profile_name)
                self.profile_list.addItem(item)

    def on_profile_selected(self, current, previous):
        """Atualiza a interface quando um perfil é selecionado."""
        # Salvar alterações do perfil anterior antes de mudar
        if previous:
            profile_name = previous.data(Qt.ItemDataRole.UserRole)
            # Verificar se o perfil ainda existe (pode ter sido excluído ou renomeado)
            # E se o nome não mudou
            if profile_name in self.profiles and previous.text() == profile_name:
                 airports_text = self.airports_edit.toPlainText().strip()
                 self.profiles[profile_name] = airports_text

        if current:
            profile_name = current.data(Qt.ItemDataRole.UserRole)
            if profile_name in self.profiles:
                # Preencher o editor de texto com a lista de aeroportos
                airports = self.profiles[profile_name]
                self.airports_edit.setText(airports)

                # Habilitar botões de edição
                self.rename_button.setEnabled(True)
                self.delete_button.setEnabled(True)
                self.airports_edit.setEnabled(True)
        else:
            # Limpar e desabilitar campos se nenhum perfil estiver selecionado
            self.airports_edit.clear()
            self.rename_button.setEnabled(False)
            self.delete_button.setEnabled(False)
            self.airports_edit.setEnabled(False)

    def add_profile(self):
        """Adiciona um novo perfil."""
        profile_name, ok = QInputDialog.getText(
            self, "Novo Perfil", "Nome do perfil:", QLineEdit.EchoMode.Normal
        )
        if ok and profile_name:
            # Validar nome (não pode ser vazio ou "Manual")
            profile_name = profile_name.strip()
            if not profile_name or profile_name == "Manual":
                 QMessageBox.warning(self, "Nome Inválido", "O nome do perfil não pode ser vazio ou 'Manual'.")
                 return

            if profile_name in self.profiles:
                QMessageBox.warning(
                    self, "Perfil Existente",
                    f"Um perfil com o nome '{profile_name}' já existe."
                )
                return

            # Adicionar o novo perfil com uma lista vazia
            self.profiles[profile_name] = ""

            # Atualizar a lista de perfis
            self.populate_profile_list()

            # Selecionar o novo perfil
            for i in range(self.profile_list.count()):
                item = self.profile_list.item(i)
                if item.data(Qt.ItemDataRole.UserRole) == profile_name:
                    self.profile_list.setCurrentItem(item)
                    break

    def rename_profile(self):
        """Renomeia o perfil selecionado."""
        current_item = self.profile_list.currentItem()
        if not current_item:
            return

        current_name = current_item.data(Qt.ItemDataRole.UserRole)
        new_name, ok = QInputDialog.getText(
            self, "Renomear Perfil", "Novo nome do perfil:",
            QLineEdit.EchoMode.Normal, current_name
        )

        if ok and new_name:
            new_name = new_name.strip()
            if not new_name or new_name == "Manual":
                 QMessageBox.warning(self, "Nome Inválido", "O nome do perfil não pode ser vazio ou 'Manual'.")
                 return

            if new_name != current_name:
                if new_name in self.profiles:
                    QMessageBox.warning(
                        self, "Perfil Existente",
                        f"Um perfil com o nome '{new_name}' já existe."
                    )
                    return

                # Transferir dados do perfil antigo para o novo nome
                # Garantir que salvamos o conteúdo atual do editor antes de renomear
                current_airports = self.airports_edit.toPlainText().strip()
                self.profiles[new_name] = current_airports
                if current_name in self.profiles: # Checar se ainda existe antes de deletar
                    del self.profiles[current_name]

                # Atualizar a lista
                self.populate_profile_list()

                # Selecionar o perfil renomeado
                new_item_found = False
                for i in range(self.profile_list.count()):
                    item = self.profile_list.item(i)
                    if item.data(Qt.ItemDataRole.UserRole) == new_name:
                        self.profile_list.setCurrentItem(item)
                        new_item_found = True
                        break
                # Se por algum motivo não encontrar (não deveria acontecer), desabilitar campos
                if not new_item_found:
                    self.airports_edit.clear()
                    self.rename_button.setEnabled(False)
                    self.delete_button.setEnabled(False)
                    self.airports_edit.setEnabled(False)


    def delete_profile(self):
        """Exclui o perfil selecionado."""
        current_item = self.profile_list.currentItem()
        if not current_item:
            return

        profile_name = current_item.data(Qt.ItemDataRole.UserRole)

        # Reconfirmar que não é o perfil Manual (proteção extra)
        if profile_name == "Manual":
            QMessageBox.warning(
                self, "Perfil Protegido",
                f"O perfil 'Manual' não pode ser excluído."
            )
            return

        reply = QMessageBox.question(
            self, "Confirmar Exclusão",
            f"Tem certeza que deseja excluir o perfil '{profile_name}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Remover o perfil
            if profile_name in self.profiles:
                del self.profiles[profile_name]

                # Atualizar a lista
                self.populate_profile_list()

                # Limpar os campos de edição pois o item selecionado sumiu
                self.airports_edit.clear()
                self.rename_button.setEnabled(False)
                self.delete_button.setEnabled(False)
                self.airports_edit.setEnabled(False)


class AirportWaypointFinder(QMainWindow):
    def __init__(self):
        super().__init__()
        # VERSÃO INCREMENTADA PARA REFLETIR MUDANÇAS
        self.setWindowTitle("SIDSTARS Finder 0.61")
        self.setMinimumSize(400, 420)
        # Aumentar um pouco a largura padrão para a nova coluna DIST
        self.resize(750, 550)

        # Variáveis para armazenar o caminho da base de dados e a conexão
        self.db_path = ""
        self.conn = None

        # Cache de dados para aeroportos
        self.sid_data = []
        self.star_data = []
        self.loaded_airports = []
        self.runway_filters = {}  # Armazena filtros de pista para cada aeroporto
        # Cache para distâncias CUMULATIVAS por seqno
        self.procedure_distances = {}

        # Timer para busca automática
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.perform_search)

        # Flag para controle de exibição dos fixos intermediários:
        # False = filtra e exibe somente os waypoints desejados (final SID ou inicial STAR)
        # True  = exibe TODOS os fixos, incluindo os intermediários.
        self.show_intermediate_waypoints = False

        # Variável para controlar o tema - agora o tema escuro é o padrão
        self.dark_theme_enabled = True

        # Variável para controlar a âncora
        self.anchor_button = None
        self.anchor_mode = "Disabled"  # Modo padrão da âncora (Disabled, Global ou Aurora)

        # NOVA FUNCIONALIDADE: Sistema de Perfis de Aeroportos
        self.config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "airport_profiles.json")
        self.load_profiles()  # Carregar perfis existentes

        # --- CORREÇÃO: Inverter a ordem de setup_ui e create_menu ---
        # Configurar a interface PRIMEIRO
        self.setup_ui()
        # Criar os menus DEPOIS (pois eles podem depender da UI)
        self.create_menu()
        # -------------------------------------------------------------

        # Tentar encontrar e carregar automaticamente a base de dados mais recente
        latest_db = self.find_latest_database()
        if latest_db:
            self.db_path = latest_db
            self.file_path_label.setText(os.path.basename(latest_db))
            try:
                if self.conn:
                    self.conn.close()
                self.conn = sqlite3.connect(self.db_path)
                self.status_label.setText("Base de dados conectada automaticamente. Adicione aeroportos e pressione Enter.")
            except sqlite3.Error as e:
                self.file_path_label.setText(f"Erro ao abrir o arquivo: {str(e)}")
                self.db_path = ""
                self.conn = None

        # Configurar o atalho F1 para focar no campo de busca
        self.search_shortcut = QShortcut(QKeySequence("F1"), self)
        self.search_shortcut.activated.connect(self.focus_search_input)

        # Aplicar o tema escuro por padrão
        self.apply_dark_theme()

    def load_profiles(self):
        """Carrega os perfis de aeroportos do arquivo de configuração."""
        # Inicializar apenas com o perfil Manual (este sempre existirá)
        self.airport_profiles = {
            "Manual": ""  # Perfil manual sempre começa vazio
        }

        # Tentar carregar perfis salvos do arquivo JSON
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r') as file:
                    loaded_profiles = json.load(file)
                    # Adicionar todos os perfis carregados do arquivo
                    # Garantir que o perfil Manual do arquivo não sobrescreva o nosso (se existir)
                    for name, airports in loaded_profiles.items():
                        if name != "Manual":
                            self.airport_profiles[name] = airports
            else:
                # Se o arquivo não existe, inicializar os perfis padrão e salvar
                # Adicionar perfis padrão apenas na primeira execução
                self.airport_profiles["Brasil"] = "SBAC, SBAE, SBAF, SBAN, SBAQ, SBAR, SBAU, SBBE, SBBH, SBBI, SBBQ, SBBR, SBBU, SBBV, SBCA, SBCB, SBCF, SBCG, SBCH, SBCN, SBCO, SBCP, SBCR, SBCT, SBCX, SBCY, SBCZ, SBDN, SBDO, SBEG, SBES, SBFI, SBFL, SBFN, SBFZ, SBGL, SBGM, SBGO, SBGP, SBGR, SBGV, SBGW, SBIP, SBIZ, SBJA, SBJD, SBJE, SBJP, SBJU, SBJV, SBKP, SBLO, SBLS, SBMA, SBMG, SBMI, SBMK, SBMN, SBMO, SBMQ, SBNF, SBNM, SBNT, SBPA, SBPF, SBPJ, SBPO, SBPP, SBPS, SBPV, SBRB, SBRD, SBRF, SBRJ, SBRP, SBSC, SBSG, SBSI, SBSJ, SBSL, SBSM, SBSN, SBSO, SBSP, SBST, SBSV, SBTE, SBTT, SBUA, SBUL, SBUY, SBVC, SBVT, SBYS, SNCP"
                self.airport_profiles["SBRE"] = "SBAC, SBAR, SBFN, SBFZ, SBGV, SBIL, SBIP, SBJE, SBJP, SBJU, SBKG, SBMO, SBMS, SBNT, SBPL, SBPS, SBRF, SBSG, SBSV, SBTC, SBTE, SBTV, SBVC, SBVT"
                # Salvar os perfis padrão no arquivo
                self.save_profiles()
        except Exception as e:
            print(f"Erro ao carregar perfis: {e}")
            # Em caso de erro, garantir que o perfil Manual exista
            self.airport_profiles = {"Manual": ""}

    def save_profiles(self):
        """Salva os perfis de aeroportos no arquivo de configuração."""
        try:
            # Criar uma cópia para não salvar o perfil Manual no JSON
            profiles_to_save = self.airport_profiles.copy()
            if "Manual" in profiles_to_save:
                del profiles_to_save["Manual"]

            with open(self.config_path, 'w') as file:
                json.dump(profiles_to_save, file, indent=4)
        except Exception as e:
            print(f"Erro ao salvar perfis: {e}")
            QMessageBox.warning(
                self, "Erro ao Salvar",
                f"Não foi possível salvar os perfis: {str(e)}"
            )

    def setup_ui(self):
        # Widget central
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Layout principal
        main_layout = QVBoxLayout(central_widget)

        # Área de informação da base de dados
        db_layout = QHBoxLayout()
        self.db_label = QLabel("Base de dados:")
        self.file_path_label = QLabel("Nenhum arquivo selecionado")
        self.file_path_label.setStyleSheet("font-weight: bold;")
        db_layout.addWidget(self.db_label)
        db_layout.addWidget(self.file_path_label, 1)

        # Área de entrada de aeroportos
        airport_layout = QHBoxLayout()
        self.airport_label = QLabel("Aeroportos (separados por vírgula):")
        self.airport_input = QLineEdit() # *** self.airport_input é criado AQUI ***
        self.airport_input.setPlaceholderText("Ex: SBSV, SBFZ, SBSG. Use números para filtrar pistas: SBGR10, SBRF18, SBKP15")
        self.airport_input.textChanged.connect(self.on_airport_changed)
        self.airport_input.returnPressed.connect(self.on_airport_enter_pressed) # Usar returnPressed

        airport_layout.addWidget(self.airport_label)
        airport_layout.addWidget(self.airport_input, 1)

        # Área de busca
        search_layout = QHBoxLayout()
        self.search_label = QLabel("Buscar waypoint:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Digite para iniciar a busca")
        self.search_input.textChanged.connect(self.on_search_changed)
        search_layout.addWidget(self.search_label)
        search_layout.addWidget(self.search_input, 1)

        # Status da busca
        self.status_label = QLabel("")
        self.status_label.setStyleSheet("color: #666;") # Cinza mais escuro para status

        # Criar duas tabelas: uma para SIDs e outra para STARs
        table_container = QSplitter(Qt.Orientation.Vertical)
        table_container.setHandleWidth(10)

        # Estilo do handle do QSplitter (reaplicado para garantir consistência)
        table_container.setStyleSheet("""
            QSplitter::handle:vertical {
                background-color: #4A4A4F; /* Cor do handle */
                height: 1px; /* Altura fina */
                margin-left: 5px; /* Margens para não ocupar toda a largura */
                margin-right: 5px;
                border-top: 1px solid #555555; /* Borda superior */
                border-bottom: 1px solid #555555; /* Borda inferior */
            }
            QSplitter::handle:vertical:hover {
                background-color: #5A5A5F; /* Cor ao passar o mouse */
            }
            QSplitter::handle:vertical:pressed {
                background-color: #6A6A6F; /* Cor ao pressionar */
            }
        """)


        # --- Tabela SIDs ---
        sid_widget = QWidget()
        sid_layout = QVBoxLayout(sid_widget)
        sid_layout.setContentsMargins(0, 0, 0, 0) # Remover margens internas
        sid_label = QLabel("SIDs (Saídas)")
        sid_label.setStyleSheet("font-weight: bold; font-size: 14px; padding-left: 5px;")
        self.sid_table = QTableWidget()
        # REINTEGRADO: 6 colunas com DIST
        self.sid_table.setColumnCount(6)
        self.sid_table.setHorizontalHeaderLabels(["APT", "RWY", "SID", "WPT", "DIST", "NAME"])
        sid_header = self.sid_table.horizontalHeader()
        # Colunas 0-4 (APT, RWY, SID, WPT, DIST) são interativas
        for i in range(5):
            sid_header.setSectionResizeMode(i, QHeaderView.ResizeMode.Interactive)
        # Coluna 5 (NAME) estica
        sid_header.setSectionResizeMode(5, QHeaderView.ResizeMode.Stretch)
        sid_header.sectionResized.connect(self.sync_star_columns_from_sid)

        self.sid_table.horizontalHeader().setSectionsMovable(True)
        self.sid_table.setSortingEnabled(True)
        self.sid_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.sid_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.sid_table.setAlternatingRowColors(True) # Melhora a legibilidade
        self.sid_table.cellClicked.connect(self.copy_cell_to_clipboard)
        sid_layout.addWidget(sid_label)
        sid_layout.addWidget(self.sid_table)

        # --- Tabela STARs ---
        star_widget = QWidget()
        star_layout = QVBoxLayout(star_widget)
        star_layout.setContentsMargins(0, 0, 0, 0) # Remover margens internas
        star_label = QLabel("STARs (Chegadas)")
        star_label.setStyleSheet("font-weight: bold; font-size: 14px; padding-left: 5px;")
        self.star_table = QTableWidget()
        # REINTEGRADO: 6 colunas com DIST
        self.star_table.setColumnCount(6)
        self.star_table.setHorizontalHeaderLabels(["APT", "RWY", "STAR", "WPT", "DIST", "NAME"])
        star_header = self.star_table.horizontalHeader()
        # Colunas 0-4 (APT, RWY, STAR, WPT, DIST) são interativas
        for i in range(5):
            star_header.setSectionResizeMode(i, QHeaderView.ResizeMode.Interactive)
        # Coluna 5 (NAME) estica
        star_header.setSectionResizeMode(5, QHeaderView.ResizeMode.Stretch)
        star_header.sectionResized.connect(self.sync_sid_columns_from_star)

        self.star_table.horizontalHeader().setSectionsMovable(True)
        self.star_table.setSortingEnabled(True)
        self.star_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.star_table.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.star_table.setAlternatingRowColors(True) # Melhora a legibilidade
        self.star_table.cellClicked.connect(self.copy_cell_to_clipboard)
        star_layout.addWidget(star_label)
        star_layout.addWidget(self.star_table)

        # Adicionar tabelas ao splitter
        table_container.addWidget(sid_widget)
        table_container.addWidget(star_widget)
        table_container.setSizes([int(self.height() * 0.5), int(self.height() * 0.5)]) # Tamanho inicial das duas partes

        # Adicionar layouts ao layout principal
        main_layout.addLayout(db_layout)
        main_layout.addLayout(airport_layout)
        main_layout.addLayout(search_layout)
        main_layout.addWidget(self.status_label)
        main_layout.addWidget(table_container, 1)  # 1 = stretch factor para ocupar espaço disponível

        # Barra de status com indicador de redimensionamento
        self.setStatusBar(QStatusBar())
        self.statusBar().setSizeGripEnabled(True) # Habilita o grip de redimensionamento

    def on_airport_enter_pressed(self):
        """Acionado quando Enter é pressionado no campo de aeroportos"""
        # Carregar os aeroportos primeiro
        self.load_airport_data()

        # Mover o foco para o campo de busca
        self.focus_search_input()

    def create_menu(self):
        menubar = self.menuBar()

        # Menu Arquivo
        file_menu = menubar.addMenu("Arquivo")

        # Ação para selecionar a base de dados
        open_db_action = QAction("Selecionar base de dados", self)
        open_db_action.triggered.connect(self.browse_file)
        file_menu.addAction(open_db_action)

        # Submenu "Selecione aeroportos"
        self.select_airports_menu = file_menu.addMenu("Selecione aeroportos")

        # Ação para gerenciar perfis
        manage_profiles_action = QAction("Gerenciar perfis...", self)
        manage_profiles_action.triggered.connect(self.open_profile_manager)
        # Inserir "Gerenciar perfis..." e um separador no início do submenu
        self.select_airports_menu.addAction(manage_profiles_action)
        self.select_airports_menu.addSeparator()


        # Grupo de ações para garantir escolha exclusiva
        self.airport_selection_group = QActionGroup(self)
        self.airport_selection_group.setExclusive(True)

        # Preencher perfis do menu
        self.update_profile_menu() # Esta chamada agora é segura

        # Adicionar separador
        file_menu.addSeparator()

        # Ação para sair do aplicativo
        exit_action = QAction("Sair", self)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Menu Opções
        options_menu = menubar.addMenu("Opções")

        # Ação "Mostrar fixos intermediários" (checkable)
        self.show_fixos_action = QAction("Mostrar fixos intermediários", self)
        self.show_fixos_action.setCheckable(True)
        self.show_fixos_action.setChecked(False) # Começa desmarcado
        self.show_fixos_action.triggered.connect(self.toggle_show_fixos)
        options_menu.addAction(self.show_fixos_action)

        # Ação "Janela sempre visível" (checkable)
        self.always_on_top_action = QAction("Janela sempre visível", self)
        self.always_on_top_action.setCheckable(True)
        self.always_on_top_action.setChecked(False)
        self.always_on_top_action.triggered.connect(self.toggle_always_on_top)
        options_menu.addAction(self.always_on_top_action)

        # Ação "Ativar tema claro" (checkable)
        self.light_theme_action = QAction("Ativar tema claro", self)
        self.light_theme_action.setCheckable(True)
        self.light_theme_action.setChecked(False) # Começa com tema escuro
        self.light_theme_action.triggered.connect(self.toggle_theme)
        options_menu.addAction(self.light_theme_action)

        # Submenu para o modo âncora
        anchor_menu = options_menu.addMenu("Ativar âncora")

        # Grupo de ações para os modos de âncora (exclusivos entre si)
        self.anchor_group = QActionGroup(self)
        self.anchor_group.setExclusive(True)

        # Ação para modo Desativado (padrão)
        self.anchor_disabled_action = QAction("Desativado", self)
        self.anchor_disabled_action.setCheckable(True)
        self.anchor_disabled_action.setChecked(True)  # Padrão
        self.anchor_disabled_action.triggered.connect(lambda: self.set_anchor_mode("Disabled"))
        self.anchor_group.addAction(self.anchor_disabled_action)
        anchor_menu.addAction(self.anchor_disabled_action)

        # Ação para o modo Global
        self.global_mode_action = QAction("Modo global", self)
        self.global_mode_action.setCheckable(True)
        self.global_mode_action.triggered.connect(lambda: self.set_anchor_mode("Global"))
        self.anchor_group.addAction(self.global_mode_action)
        anchor_menu.addAction(self.global_mode_action)

        # Ação para o modo Aurora
        self.aurora_mode_action = QAction("Modo Aurora", self)
        self.aurora_mode_action.setCheckable(True)
        self.aurora_mode_action.triggered.connect(lambda: self.set_anchor_mode("Aurora"))
        self.anchor_group.addAction(self.aurora_mode_action)
        anchor_menu.addAction(self.aurora_mode_action)

        # Desabilitar as opções de modo se não houver suporte para rastreamento de processos
        if not process_tracking_available:
            self.aurora_mode_action.setEnabled(False)
            self.aurora_mode_action.setText("Modo Aurora (requer win32gui/psutil)")

    def set_anchor_mode(self, mode):
        """Define o modo da âncora"""
        self.anchor_mode = mode

        # Criar ou destruir a âncora com base no modo
        if mode == "Disabled":
            # Desativar a âncora
            if self.anchor_button:
                self.anchor_button.close()
                self.anchor_button = None
            self.status_label.setText("Âncora desativada.")
        else:
            # Criar e mostrar o botão de âncora (como janela independente)
            if not self.anchor_button:
                self.anchor_button = AnchorButton(parent_window=self, anchor_mode=mode)

                # Posicionar no centro da tela inicialmente
                try:
                    screen_geometry = QApplication.primaryScreen().geometry()
                    center_point = screen_geometry.center()
                    self.anchor_button.move(center_point.x() - 20, center_point.y() - 20)
                except Exception as e:
                    print(f"Erro ao posicionar âncora: {e}")
                    # Posição padrão caso falhe
                    self.anchor_button.move(100, 100)
            else:
                # Atualizar o modo da âncora existente
                self.anchor_button.set_anchor_mode(mode)

            # Aplicar o estilo correto ao botão (caso tenha sido recriado ou tema mudou)
            if self.dark_theme_enabled:
                self.anchor_button.apply_dark_style()
            else:
                self.anchor_button.apply_light_style()

            # No modo Aurora, a visibilidade é controlada pelo timer
            # Nos outros modos (Global), deve ser visível
            if mode == "Global" or not process_tracking_available:
                self.anchor_button.show()
            elif mode == "Aurora":
                # No modo Aurora, verificar imediatamente se deve mostrar
                self.anchor_button.check_foreground_process()

            # Mensagem informativa para o usuário
            if mode == "Global":
                self.status_label.setText("Âncora ativada no modo Global (sempre visível).")
            else:  # Aurora
                if process_tracking_available:
                    self.status_label.setText("Âncora ativada no modo Aurora (visível apenas quando Aurora.exe ou python.exe estão em primeiro plano).")
                else:
                    self.status_label.setText("Modo Aurora não disponível - bibliotecas win32gui e psutil são necessárias.")

    def update_profile_menu(self):
        """Atualiza o menu de perfis com os perfis disponíveis."""
        # Limpar apenas as ações de perfis (manter "Gerenciar..." e separador)
        actions_to_remove = []
        for action in self.select_airports_menu.actions():
             # Identificar ações de perfil pelo fato de pertencerem ao grupo
             if action in self.airport_selection_group.actions():
                 actions_to_remove.append(action)

        for action in actions_to_remove:
             self.select_airports_menu.removeAction(action)
             self.airport_selection_group.removeAction(action)

        # Adicionar os perfis (incluindo Manual) ao menu e ao grupo
        current_profile_in_input = self.airport_input.text()
        manual_selected = True # Assume manual por padrão

        profile_names = sorted(self.airport_profiles.keys())
        # Colocar "Manual" no topo da lista se existir
        if "Manual" in profile_names:
            profile_names.remove("Manual")
            profile_names.insert(0, "Manual")

        for profile_name in profile_names:
            profile_action = QAction(profile_name, self)
            profile_action.setCheckable(True)

            # Lógica de seleção:
            # 1. Se o nome é "Manual", seleciona se nenhum outro perfil corresponder ao input.
            # 2. Se o nome não é "Manual", seleciona se o conteúdo do perfil corresponde ao input.
            if profile_name != "Manual" and self.airport_profiles[profile_name] == current_profile_in_input:
                profile_action.setChecked(True)
                manual_selected = False
            # Se for Manual, será checado depois se necessário

            profile_action.triggered.connect(self.on_airport_profile_selected)
            self.airport_selection_group.addAction(profile_action)
            self.select_airports_menu.addAction(profile_action)

        # Se, após verificar todos os perfis, nenhum correspondeu ao input, selecionar "Manual"
        if manual_selected:
            for action in self.airport_selection_group.actions():
                if action.text() == "Manual":
                    action.setChecked(True)
                    break

    def on_airport_profile_selected(self):
        """Acionado quando um perfil de aeroportos é selecionado no menu."""
        sender = self.sender()
        if sender and isinstance(sender, QAction):
            profile_name = sender.text()
            if profile_name in self.airport_profiles:
                # Preencher o campo de entrada com a lista de aeroportos do perfil
                self.airport_input.setText(self.airport_profiles[profile_name])
                self.status_label.setText(f"Perfil '{profile_name}' selecionado. Pressione Enter ou modifique para carregar.")
                # NÃO carregar automaticamente, esperar Enter ou mudança de foco.
                # self.load_airport_data() # Removido auto-load

    def open_profile_manager(self):
        """Abre o diálogo de gerenciamento de perfis."""
        dialog = ProfileManagerDialog(self, self.airport_profiles) # Passar cópia
        result = dialog.exec()

        if result == QDialog.DialogCode.Accepted:
            # Atualizar os perfis com as alterações do diálogo
            self.airport_profiles = dialog.profiles

            # Garantir que o perfil Manual sempre exista internamente
            if "Manual" not in self.airport_profiles:
                self.airport_profiles["Manual"] = ""

            # Salvar os perfis atualizados (exceto Manual)
            self.save_profiles()

            # Atualizar o menu de perfis na UI principal
            self.update_profile_menu()

            self.status_label.setText("Perfis de aeroportos atualizados com sucesso.")

    def sync_star_columns_from_sid(self, logical_index, old_size, new_size):
        """Sincroniza o redimensionamento das colunas 0-4 da SID para a STAR."""
        # Sincronizar colunas 0, 1, 2, 3, 4 (APT, RWY, SID, WPT, DIST)
        if logical_index < 5:
            star_header = self.star_table.horizontalHeader()
            star_header.blockSignals(True)
            star_header.resizeSection(logical_index, new_size)
            star_header.blockSignals(False)

    def sync_sid_columns_from_star(self, logical_index, old_size, new_size):
        """Sincroniza o redimensionamento das colunas 0-4 da STAR para a SID."""
         # Sincronizar colunas 0, 1, 2, 3, 4 (APT, RWY, STAR, WPT, DIST)
        if logical_index < 5:
            sid_header = self.sid_table.horizontalHeader()
            sid_header.blockSignals(True)
            sid_header.resizeSection(logical_index, new_size)
            sid_header.blockSignals(False)


    def copy_cell_to_clipboard(self, row, column):
        """Copia o texto da célula clicada para o clipboard."""
        table = self.sender()
        if isinstance(table, QTableWidget):
            item = table.item(row, column)
            if item:
                clipboard = QApplication.clipboard()
                clipboard.setText(item.text())
                self.status_label.setText(f"'{item.text()}' copiado para o clipboard")

    def focus_search_input(self):
        """Coloca o foco no campo de busca de waypoint e seleciona o texto atual."""
        self.search_input.setFocus()
        self.search_input.selectAll()

    def toggle_theme(self):
        """Alterna entre tema claro e escuro."""
        # O estado de `isChecked` reflete o desejo de ATIVAR o tema claro
        self.dark_theme_enabled = not self.light_theme_action.isChecked()
        if self.dark_theme_enabled:
            self.apply_dark_theme()
        else:
            self.apply_light_theme()

        # Atualizar o estilo da âncora
        if self.anchor_button:
             if self.dark_theme_enabled:
                 self.anchor_button.apply_dark_style()
             else:
                 self.anchor_button.apply_light_style()

    def apply_dark_theme(self):
        """Aplica o tema escuro à aplicação."""
        # Estilo aprimorado para tema escuro
        self.setStyleSheet("""
            QMainWindow, QWidget {
                background-color: #2D2D30;
                color: #E6E6E6; /* Cor de texto clara */
            }
            QTableWidget {
                background-color: #252526;
                color: #E6E6E6;
                gridline-color: #4A4A4F; /* Linhas da grade mais suaves */
                border: 1px solid #4A4A4F;
                alternate-background-color: #333337; /* Cor alternada */
                selection-background-color: #007ACC; /* Cor de seleção (azul) */
                selection-color: #FFFFFF; /* Texto selecionado branco */
            }
            QTableWidget::item {
                padding: 4px; /* Mais espaçamento interno */
                border-bottom: 1px solid #4A4A4F; /* Linha separadora sutil */
            }
            QHeaderView::section {
                background-color: #3E3E42;
                color: #E6E6E6;
                border: 1px solid #555555;
                padding: 5px; /* Padding no header */
                font-weight: bold;
            }
            QLineEdit {
                background-color: #333337;
                color: #E6E6E6;
                border: 1px solid #555555;
                padding: 4px; /* Padding interno */
                border-radius: 3px; /* Cantos arredondados */
            }
            QPushButton {
                background-color: #3E3E42;
                color: #E6E6E6;
                border: 1px solid #555555;
                padding: 5px 15px; /* Padding */
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #505055; /* Levemente mais claro no hover */
                border-color: #666666;
            }
            QPushButton:pressed {
                background-color: #2A2A2E; /* Mais escuro ao pressionar */
            }
            QMenuBar {
                background-color: #2D2D30;
                color: #E6E6E6;
            }
            QMenuBar::item {
                background-color: transparent;
                padding: 4px 10px;
            }
            QMenuBar::item:selected {
                background-color: #3E3E42;
            }
            QMenu {
                background-color: #2D2D30;
                color: #E6E6E6;
                border: 1px solid #555555;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 25px 6px 25px; /* Espaçamento */
                border: 1px solid transparent; /* Remove borda padrão */
            }
            QMenu::item:selected {
                background-color: #007ACC; /* Azul na seleção */
                color: #FFFFFF;
            }
            QMenu::separator {
                height: 1px;
                background-color: #555555;
                margin-left: 10px;
                margin-right: 10px;
            }
            /* Estilo do handle do QSplitter já definido em setup_ui */
            QStatusBar {
                background-color: #2D2D30;
                color: #AAAAAA; /* Cor de status mais suave */
            }
            QStatusBar::item {
                border: none; /* Remover borda padrão */
            }
            QListWidget { /* Estilo para ProfileManagerDialog */
                background-color: #252526;
                color: #E6E6E6;
                border: 1px solid #555555;
                alternate-background-color: #333337;
            }
            QListWidget::item:selected {
                background-color: #007ACC;
                color: #FFFFFF;
            }
            QTextEdit { /* Estilo para ProfileManagerDialog */
                background-color: #333337;
                color: #E6E6E6;
                border: 1px solid #555555;
                padding: 4px;
                border-radius: 3px;
            }
            QLabel { /* Estilo geral para Labels */
                padding: 2px;
            }
        """)


    def apply_light_theme(self):
        """Aplica o tema claro à aplicação."""
        self.setStyleSheet("""
            QMainWindow, QWidget {
                background-color: #F0F0F0;
                color: #202020;
            }
            QTableWidget {
                background-color: #FFFFFF;
                color: #202020;
                gridline-color: #D0D0D0; /* Linhas da grade mais claras */
                border: 1px solid #CCCCCC;
                alternate-background-color: #F5F5F5; /* Cor alternada suave */
                selection-background-color: #D0E8FF; /* Azul claro seleção */
                selection-color: #000000; /* Texto selecionado preto */
            }
            QTableWidget::item {
                padding: 4px;
                border-bottom: 1px solid #E0E0E0; /* Linha separadora clara */
            }
            QHeaderView::section {
                background-color: #E6E6E6;
                color: #202020;
                border: 1px solid #CCCCCC;
                padding: 5px;
                font-weight: bold;
            }
            QLineEdit {
                background-color: #FFFFFF;
                color: #202020;
                border: 1px solid #CCCCCC;
                padding: 4px;
                border-radius: 3px;
            }
            QPushButton {
                background-color: #E6E6E6;
                color: #202020;
                border: 1px solid #CCCCCC;
                padding: 5px 15px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #D5D5D5;
                border-color: #BBBBBB;
            }
            QPushButton:pressed {
                background-color: #C5C5C5;
            }
            QMenuBar {
                background-color: #F0F0F0;
                color: #202020;
            }
            QMenuBar::item {
                background-color: transparent;
                padding: 4px 10px;
            }
            QMenuBar::item:selected {
                background-color: #E0E0E0;
            }
            QMenu {
                background-color: #F8F8F8; /* Fundo do menu um pouco diferente */
                color: #202020;
                border: 1px solid #CCCCCC;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 25px 6px 25px;
                border: 1px solid transparent;
            }
            QMenu::item:selected {
                background-color: #D0E8FF; /* Azul claro seleção */
                color: #000000;
            }
             QMenu::separator {
                height: 1px;
                background-color: #CCCCCC;
                margin-left: 10px;
                margin-right: 10px;
            }
            /* Estilo do handle do QSplitter (claro) */
            QSplitter::handle:vertical {
                background-color: #E0E0E0;
                height: 1px;
                margin-left: 5px;
                margin-right: 5px;
                border-top: 1px solid #CCCCCC;
                border-bottom: 1px solid #CCCCCC;
            }
            QSplitter::handle:vertical:hover {
                background-color: #D0D0D0;
            }
            QSplitter::handle:vertical:pressed {
                background-color: #C0C0C0;
            }
            QStatusBar {
                background-color: #F0F0F0;
                color: #555555; /* Cor de status mais escura */
            }
             QStatusBar::item {
                border: none;
            }
            QListWidget { /* Estilo para ProfileManagerDialog */
                background-color: #FFFFFF;
                color: #202020;
                border: 1px solid #CCCCCC;
                alternate-background-color: #F5F5F5;
            }
            QListWidget::item:selected {
                background-color: #D0E8FF;
                color: #000000;
            }
            QTextEdit { /* Estilo para ProfileManagerDialog */
                background-color: #FFFFFF;
                color: #202020;
                border: 1px solid #CCCCCC;
                padding: 4px;
                border-radius: 3px;
            }
            QLabel {
                 padding: 2px;
            }
        """)


    def toggle_always_on_top(self):
        """Define a janela como "sempre visível" ou não."""
        if self.always_on_top_action.isChecked():
            self.setWindowFlags(self.windowFlags() | Qt.WindowType.WindowStaysOnTopHint)
        else:
            self.setWindowFlags(self.windowFlags() & ~Qt.WindowType.WindowStaysOnTopHint)
        # É necessário mostrar a janela novamente após alterar as flags
        self.show()

    def toggle_show_fixos(self):
        """Atualiza a flag e refaz a busca se houver termo."""
        self.show_intermediate_waypoints = self.show_fixos_action.isChecked()
        # Se houver um termo de busca já digitado, refaz a busca
        # para aplicar ou remover o filtro de fixos intermediários.
        if self.search_input.text().strip():
            self.perform_search()

    def browse_file(self):
        """Abre diálogo para selecionar arquivo .s3db."""
        file_path, _ = QFileDialog.getOpenFileName(self, "Selecionar arquivo SQLite", "", "SQLite Files (*.s3db);;All Files (*)")
        if file_path:
            # Fechar conexão anterior, se existir
            if self.conn:
                try:
                    self.conn.close()
                    print("Conexão anterior fechada.")
                except sqlite3.Error as e:
                    print(f"Erro ao fechar conexão anterior: {e}")
                self.conn = None # Garantir que está None

            self.db_path = file_path
            self.file_path_label.setText(os.path.basename(file_path))
            try:
                self.conn = sqlite3.connect(self.db_path)
                self.status_label.setText("Base de dados conectada. Adicione aeroportos e pressione Enter.")
                # Limpar dados antigos e UI ao carregar nova DB
                self.sid_data = []
                self.star_data = []
                self.loaded_airports = []
                self.runway_filters = {}
                self.procedure_distances = {} # Limpar cache de distâncias
                self.sid_table.setRowCount(0)
                self.star_table.setRowCount(0)
                # Limpar inputs também pode ser útil
                self.airport_input.clear()
                self.search_input.clear()

            except sqlite3.Error as e:
                self.file_path_label.setText(f"Erro ao abrir o arquivo: {str(e)}")
                self.conn = None
                # Limpar UI mesmo em caso de erro
                self.sid_table.setRowCount(0)
                self.star_table.setRowCount(0)

    def on_airport_changed(self):
        """Atualiza status e seleção de perfil ao digitar no campo de aeroportos."""
        self.status_label.setText("Pressione Enter para carregar os aeroportos e iniciar a busca.")
        # Ao mudar o texto, verificar se corresponde a algum perfil
        # e marcar o perfil correspondente ou 'Manual'
        is_manual = True
        current_text = self.airport_input.text().strip() # Usar strip para comparação

        # Se o campo estiver vazio, selecionar Manual
        if not current_text:
            is_manual = True
        else:
            # Procurar correspondência exata nos perfis (exceto Manual)
            for action in self.airport_selection_group.actions():
                profile_name = action.text()
                if profile_name != "Manual" and profile_name in self.airport_profiles:
                    # Comparar sem espaços extras
                    if self.airport_profiles[profile_name].strip() == current_text:
                        action.setChecked(True)
                        is_manual = False
                        break # Encontrou correspondência

        # Se nenhum perfil correspondeu (ou campo vazio), selecionar 'Manual'
        if is_manual:
             for action in self.airport_selection_group.actions():
                if action.text() == "Manual":
                    action.setChecked(True)
                    break

    def on_search_changed(self):
        """Inicia timer para busca ao digitar no campo de busca."""
        self.search_timer.start(150) # Aumentar ligeiramente o delay para 150ms

    def load_airport_data(self):
        """Carrega dados dos aeroportos informados e calcula distâncias."""
        if not self.conn:
            self.status_label.setText("Selecione uma base de dados primeiro.")
            return

        airports_text = self.airport_input.text().strip()
        if not airports_text:
            self.status_label.setText("Informe pelo menos um aeroporto para carregar.")
            # Limpar dados e UI se o input ficar vazio
            self.sid_data = []
            self.star_data = []
            self.loaded_airports = []
            self.runway_filters = {}
            self.procedure_distances = {}
            self.sid_table.setRowCount(0)
            self.star_table.setRowCount(0)
            return

        # Extrair aeroportos e filtros de pista (lógica aprimorada)
        airport_entries = [entry.strip().upper() for entry in airports_text.split(',')]
        processed_airports = set() # Usar set para evitar duplicatas
        self.runway_filters = {}
        airport_pattern = r'^([A-Z]{4})(\d{1,2}[LCR]?)?$'
        valid_entries = []

        for entry in airport_entries:
            match = re.match(airport_pattern, entry)
            if match:
                airport_code = match.group(1)
                runway_prefix = match.group(2) # Pode ser None
                processed_airports.add(airport_code)
                valid_entries.append(entry) # Adicionar entrada válida

                # Processar filtros de pista se houver prefixo
                if runway_prefix:
                    if airport_code not in self.runway_filters:
                        self.runway_filters[airport_code] = set() # Usar set

                    # Adiciona o prefixo exato (e.g., 10L, 28)
                    self.runway_filters[airport_code].add(runway_prefix)

                    # Se for só número (e.g., 10), adiciona L/C/R também
                    if runway_prefix.isdigit():
                        self.runway_filters[airport_code].add(f"{runway_prefix}L")
                        self.runway_filters[airport_code].add(f"{runway_prefix}C")
                        self.runway_filters[airport_code].add(f"{runway_prefix}R")
            # Permitir código ICAO de 4 letras sem pista
            elif len(entry) == 4 and entry.isalpha():
                processed_airports.add(entry)
                valid_entries.append(entry) # Adicionar entrada válida

        # Se nenhuma entrada válida foi processada
        if not processed_airports:
            self.status_label.setText("Nenhum código de aeroporto válido encontrado (formato AAAA ou AAAAnn[LCR]).")
            return

        self.loaded_airports = sorted(list(processed_airports))

        # Formatar string de filtros para exibição
        filter_info = ""
        if self.runway_filters:
            filter_strings = []
            for airport in sorted(self.runway_filters.keys()):
                # Converter set para lista ordenada para exibição consistente
                runways_sorted = sorted(list(self.runway_filters[airport]))
                filter_strings.append(f"{airport}: {', '.join(runways_sorted)}")
            filter_info = f" com filtros de pista ({'; '.join(filter_strings)})"


        # Atualizar menu de perfis para refletir seleção manual (se aplicável)
        self.on_airport_changed() # Garante que o menu reflete o input atual

        try:
            self.status_label.setText(f"Carregando dados para {', '.join(self.loaded_airports)}{filter_info}...")
            QApplication.processEvents() # Atualiza a UI

            # Limpar caches antes de carregar novos dados
            self.sid_data = []
            self.star_data = []
            self.procedure_distances = {}

            # Carregar dados (SID e STAR)
            self.sid_data = self.load_procedure_data(self.loaded_airports, "sids")
            self.star_data = self.load_procedure_data(self.loaded_airports, "stars")

            # Verificar se dados foram carregados
            if not self.sid_data and not self.star_data:
                 self.status_label.setText(f"Nenhum dado de SID ou STAR encontrado para os aeroportos informados.")
                 # Limpar tabelas
                 self.sid_table.setRowCount(0)
                 self.star_table.setRowCount(0)
                 return # Não prosseguir se não houver dados

            # Pré-calcular distâncias CUMULATIVAS
            self.status_label.setText(f"Calculando distâncias para procedimentos...")
            QApplication.processEvents()
            start_time = time.time()
            # Calcular para SIDs e STARs juntos
            self._calculate_and_cache_cumulative_distances(self.sid_data + self.star_data)
            end_time = time.time()
            print(f"Tempo de cálculo de distâncias cumulativas: {end_time - start_time:.3f}s") # Para debug

            # Atualizar status final
            self.status_label.setText(f"Dados carregados para {len(self.loaded_airports)} aeroportos{filter_info}. Pronto para busca. (F1 para focar)")

            # Refazer a busca se já houver texto no campo de busca
            if self.search_input.text().strip():
                self.perform_search()
            else:
                # Limpar tabelas se não houver busca ativa
                self.sid_table.setRowCount(0)
                self.star_table.setRowCount(0)

        except sqlite3.Error as e:
            self.status_label.setText(f"Erro ao carregar dados do banco: {str(e)}")
            # Limpar em caso de erro
            self.sid_data = []
            self.star_data = []
            self.loaded_airports = []
            self.runway_filters = {}
            self.procedure_distances = {}
            self.sid_table.setRowCount(0)
            self.star_table.setRowCount(0)
        except Exception as e: # Captura genérica para outros erros inesperados
            self.status_label.setText(f"Erro inesperado ao carregar dados: {str(e)}")
            print(f"Erro inesperado em load_airport_data: {e}") # Log mais detalhado
            import traceback
            traceback.print_exc() # Imprimir stack trace no console


    def load_procedure_data(self, airports, procedure_type):
        """Carrega dados do procedimento, incluindo coordenadas."""
        if not airports or not self.conn: # Verificar conexão também
            return []
        table_name = f"tbl_{procedure_type}"
        placeholders = ", ".join(["?" for _ in airports])
        # REINTEGRADO: Buscar colunas de coordenadas
        query = f"""
        SELECT
            airport_identifier,
            transition_identifier,
            procedure_identifier,
            waypoint_identifier,
            route_type,
            seqno,
            id,
            waypoint_latitude,     -- Coordenada do waypoint
            waypoint_longitude,    -- Coordenada do waypoint
            center_waypoint_latitude, -- Coordenada da Pista/Centro
            center_waypoint_longitude -- Coordenada da Pista/Centro
        FROM {table_name}
        WHERE airport_identifier IN ({placeholders})
        """
        cursor = self.conn.cursor()
        try:
            cursor.execute(query, airports)
            columns = [
                'airport_identifier', 'transition_identifier', 'procedure_identifier',
                'waypoint_identifier', 'route_type', 'seqno', 'id',
                'waypoint_latitude', 'waypoint_longitude',
                'center_waypoint_latitude', 'center_waypoint_longitude'
            ]
            # Usar fetchall() para obter todos os resultados
            rows = cursor.fetchall()
            # Converter para lista de dicionários
            result = [dict(zip(columns, row)) for row in rows]
            return result
        except sqlite3.Error as e:
             # Usar QMessageBox para erros críticos de banco
             QMessageBox.critical(self, "Erro de Banco de Dados",
                                 f"Erro ao consultar '{table_name}': {str(e)}")
             return []
        finally:
             # Garantir que o cursor seja fechado
             if cursor:
                 cursor.close()


    # RENOMEADO e MODIFICADO para calcular distâncias CUMULATIVAS
    def _calculate_and_cache_cumulative_distances(self, all_procedure_data):
        """Pré-calcula e armazena as distâncias CUMULATIVAS por seqno para cada transição."""
        self.procedure_distances = {}
        grouped_procedures = {}

        # 1. Agrupar por (airport, procedure, transition)
        for row in all_procedure_data:
            # Validar dados essenciais antes de agrupar
            apt = row.get('airport_identifier')
            proc = row.get('procedure_identifier')
            trans = row.get('transition_identifier')
            seq = row.get('seqno')
            if not all([apt, proc, trans]) or seq is None:
                # print(f"Aviso: Dados incompletos pulados no agrupamento: {row}")
                continue # Pular linha com dados faltando

            key = (apt, proc, trans)
            if key not in grouped_procedures:
                grouped_procedures[key] = []
            grouped_procedures[key].append(row)

        # 2. Calcular distância CUMULATIVA para cada grupo
        for key, waypoints in grouped_procedures.items():
            if not waypoints:
                continue

            # Ordenar waypoints pela sequência
            try:
                # Garantir que seqno seja tratado como número
                waypoints.sort(key=lambda x: int(x['seqno']))
            except (ValueError, TypeError, KeyError) as e:
                 print(f"Erro ao ordenar waypoints para {key}: {e}. Pulando cálculo.")
                 self.procedure_distances[key] = {"error": f"Erro de ordenação: {e}"}
                 continue

            cumulative_distance = 0.0
            # Dicionário para armazenar distâncias cumulativas para ESTA transição
            cumulative_distances_for_transition = {}

            # Obter coordenadas da pista (P0) do PRIMEIRO waypoint na sequência
            start_lat = waypoints[0].get('center_waypoint_latitude')
            start_lon = waypoints[0].get('center_waypoint_longitude')

            # Verifica se temos coordenadas válidas da pista para começar
            if start_lat is None or start_lon is None or start_lat == 0.0 or start_lon == 0.0:
                print(f"Aviso: Coordenadas da pista ausentes ou inválidas para {key}. Distâncias não calculadas.")
                # Marcar que não foi possível calcular para esta transição
                self.procedure_distances[key] = {"error": "Coordenadas da pista ausentes/inválidas"}
                continue # Pula para o próximo procedimento

            # Inicializar o último ponto válido como a pista
            last_valid_lat = start_lat
            last_valid_lon = start_lon

            # Iterar pelos waypoints da sequência (W1, W2, ...)
            for wp in waypoints:
                wp_seqno = wp.get('seqno')
                wp_lat = wp.get('waypoint_latitude')
                wp_lon = wp.get('waypoint_longitude')

                # Calcular segmento apenas se o waypoint ATUAL tiver coordenadas válidas
                # E se as coordenadas do PONTO ANTERIOR também forem válidas
                if wp_lat is not None and wp_lon is not None and wp_lat != 0.0 and wp_lon != 0.0 and \
                   last_valid_lat is not None and last_valid_lon is not None:

                    segment_distance = calculate_haversine(last_valid_lat, last_valid_lon, wp_lat, wp_lon)

                    # Adicionar distância do segmento à distância cumulativa
                    cumulative_distance += segment_distance

                    # Atualizar o último ponto válido para as coordenadas DESTE waypoint
                    last_valid_lat = wp_lat
                    last_valid_lon = wp_lon
                else:
                     # Se o waypoint atual não tem coordenadas válidas,
                     # a distância CUMULATIVA até este ponto é a mesma que a do ponto anterior.
                     # NÃO adicionamos distância e NÃO atualizamos last_valid_lat/lon.
                     # O próximo cálculo usará o 'last_valid_point' anterior.
                     # print(f"Debug: Waypoint {wp.get('waypoint_identifier')} seq {wp_seqno} em {key} sem coords válidas ou ponto anterior inválido, pulando segmento.")
                     pass # A distância cumulativa permanece a mesma do ponto anterior

                # Armazenar a distância CUMULATIVA atual para este seqno
                # Mesmo que o segmento não tenha sido adicionado (coords inválidas),
                # armazenamos a distância acumulada até o ponto anterior.
                cumulative_distances_for_transition[wp_seqno] = cumulative_distance

            # Armazenar o dicionário de distâncias cumulativas para a transição principal
            self.procedure_distances[key] = cumulative_distances_for_transition


    def perform_search(self):
        """Preenche as tabelas com os resultados da busca."""
        search_term = self.search_input.text().strip().upper()

        # Limpar tabelas antes de preencher
        self.sid_table.setRowCount(0)
        self.star_table.setRowCount(0)

        if len(search_term) < 2:
            # Manter a mensagem anterior se for menos de 2 caracteres
            if not search_term:
                self.status_label.setText("Digite pelo menos 2 caracteres para buscar.")
            return # Não buscar se for menos de 2 caracteres

        if not self.loaded_airports:
            self.status_label.setText("Carregue os dados dos aeroportos primeiro (pressione Enter no campo de aeroportos).")
            return

        # Realizar busca nos dados em memória
        start_time = time.time()
        # Passar o termo de busca para search_procedures
        sid_results = self.search_procedures(self.sid_data, "sids", search_term)
        star_results = self.search_procedures(self.star_data, "stars", search_term)
        end_time = time.time()
        search_duration = end_time - start_time
        print(f"Tempo de busca e formatação: {search_duration:.3f}s") # Para debug

        # Desabilitar ordenação temporariamente para melhor performance de inserção
        self.sid_table.setSortingEnabled(False)
        self.star_table.setSortingEnabled(False)

        # Preencher tabela SIDs
        self.sid_table.setRowCount(len(sid_results))
        for i, result in enumerate(sid_results):
            # Usar .get() para segurança, embora as chaves devam existir
            self.sid_table.setItem(i, 0, QTableWidgetItem(result.get('APT', '')))
            self.sid_table.setItem(i, 1, QTableWidgetItem(result.get('RWY', '')))
            self.sid_table.setItem(i, 2, QTableWidgetItem(result.get('SID', ''))) # Chave específica SID
            self.sid_table.setItem(i, 3, QTableWidgetItem(result.get('WPT', '')))
            # REINTEGRADO: Coluna DIST (índice 4)
            self.sid_table.setItem(i, 4, QTableWidgetItem(result.get('DIST', 'N/A')))
            # Coluna NAME (índice 5)
            self.sid_table.setItem(i, 5, QTableWidgetItem(result.get('NAME', '')))

        # Preencher tabela STARs
        self.star_table.setRowCount(len(star_results))
        for i, result in enumerate(star_results):
            self.star_table.setItem(i, 0, QTableWidgetItem(result.get('APT', '')))
            self.star_table.setItem(i, 1, QTableWidgetItem(result.get('RWY', '')))
            self.star_table.setItem(i, 2, QTableWidgetItem(result.get('STAR', ''))) # Chave específica STAR
            self.star_table.setItem(i, 3, QTableWidgetItem(result.get('WPT', '')))
            # REINTEGRADO: Coluna DIST (índice 4)
            self.star_table.setItem(i, 4, QTableWidgetItem(result.get('DIST', 'N/A')))
             # Coluna NAME (índice 5)
            self.star_table.setItem(i, 5, QTableWidgetItem(result.get('NAME', '')))

        # Reabilitar ordenação
        self.sid_table.setSortingEnabled(True)
        self.star_table.setSortingEnabled(True)

        # Ajustar largura das colunas ao conteúdo (opcional, pode impactar performance)
        # self.sid_table.resizeColumnsToContents()
        # self.star_table.resizeColumnsToContents()

        # Atualizar status
        total_results = len(sid_results) + len(star_results)
        filter_status = "(mostrando todos os fixos)" if self.show_intermediate_waypoints else "(fixos finais/iniciais)"
        self.status_label.setText(f"Encontrados {total_results} resultados para '{search_term}' {filter_status} ({len(sid_results)} SIDs, {len(star_results)} STARs) [{search_duration:.2f}s]")


    # MODIFICADO para buscar distância cumulativa por seqno
    def search_procedures(self, procedure_data, procedure_type, search_text):
        """
        Realiza a pesquisa nos procedimentos carregados, buscando a distância CUMULATIVA
        correspondente ao seqno do waypoint encontrado.
        """
        if not procedure_data:
            return []

        results = []
        # Usar um set para evitar adicionar a mesma combinação (APT, RWY, PROC, WPT) múltiplas vezes
        # na exibição final, especialmente quando "Mostrar fixos intermediários" está ativo.
        seen_display_entries = set()

        # --- Pré-processamento de Nomes Longos (como antes) ---
        all_long_procs = {}
        for row in procedure_data:
            proc = row.get('procedure_identifier')
            waypoint = row.get('waypoint_identifier')
            airport = row.get('airport_identifier')
            if proc and proc not in all_long_procs: # Calcular só uma vez por proc_id
                long_name = proc # Padrão é o próprio ID
                # Lógica para nomes longos (EUA e outros)
                if waypoint:
                    if airport and (airport.startswith('K') or airport.startswith('P')):
                        match = re.match(r'^([A-Z]+)(\d+[A-Z]?)$', proc)
                        if match:
                            long_name = f"{match.group(1)} {match.group(2)}"
                    # Outros casos (tentativa de formato VOR+Suffix ou Waypoint+Suffix)
                    elif len(waypoint) <= 4 and proc.startswith(waypoint):
                        suffix = proc[len(waypoint):]
                        if suffix.isdigit() or (len(suffix) > 0 and suffix[0].isdigit()): # Checa se sufixo é numérico
                           long_name = f"{waypoint} {suffix}"
                    elif len(proc) >= 4 and waypoint.startswith(proc[:4]):
                         suffix = proc[4:]
                         if suffix.isdigit() or (len(suffix) > 0 and suffix[0].isdigit()): # Checa se sufixo é numérico
                            long_name = f"{waypoint} {suffix}"
                all_long_procs[proc] = long_name
        # --- Fim Pré-processamento ---

        # --- Filtragem de Fixos Intermediários (se aplicável) ---
        data_to_search = []
        if not self.show_intermediate_waypoints:
            grouped_by_proc_trans = {}
            for row in procedure_data:
                airport = row.get('airport_identifier')
                procedure = row.get('procedure_identifier')
                transition = row.get('transition_identifier')
                seqno = row.get('seqno')

                if not all([airport, procedure, transition]) or seqno is None: continue

                key = (airport, procedure, transition)
                try:
                    seqno_int = int(seqno) # Garantir que é int para comparação
                except (ValueError, TypeError):
                    continue # Pular se seqno não for numérico

                if key not in grouped_by_proc_trans:
                    grouped_by_proc_trans[key] = row
                else:
                    current = grouped_by_proc_trans[key]
                    try:
                        current_seqno_int = int(current['seqno'])
                    except (ValueError, TypeError):
                         grouped_by_proc_trans[key] = row # Substituir se o atual for inválido
                         continue

                    # Manter o waypoint relevante (final da SID, inicial da STAR)
                    if procedure_type == "sids":
                        if seqno_int > current_seqno_int:
                            grouped_by_proc_trans[key] = row
                    elif procedure_type == "stars":
                         if seqno_int < current_seqno_int:
                            grouped_by_proc_trans[key] = row

            data_to_search = list(grouped_by_proc_trans.values())
        else:
            # Usar todos os dados se a opção estiver marcada
            data_to_search = procedure_data
        # --- Fim Filtragem ---

        # --- Mapeamento de Transições de Pista (como antes) ---
        airport_runway_transitions = {}
        for row in procedure_data: # Usar *todos* os dados para mapear pistas
             apt = row.get('airport_identifier')
             proc = row.get('procedure_identifier')
             trans = row.get('transition_identifier')
             if not all([apt, proc, trans]): continue

             if apt not in airport_runway_transitions:
                 airport_runway_transitions[apt] = {}
             if proc not in airport_runway_transitions[apt]:
                  airport_runway_transitions[apt][proc] = set() # Usar set

             # Mapear RWY -> Identificador de Pista (e.g., 10L) ou "ALL"
             if trans == "ALL":
                  airport_runway_transitions[apt][proc].add("ALL")
             elif trans.startswith("RW"):
                  match_lcr = re.match(r'^RW(\d{2}[LCR]?)$', trans)
                  match_b = re.match(r'^RW(\d{2})B$', trans)
                  if match_lcr:
                      airport_runway_transitions[apt][proc].add(match_lcr.group(1))
                  elif match_b:
                      base_rwy = match_b.group(1)
                      airport_runway_transitions[apt][proc].add(f"{base_rwy}L")
                      airport_runway_transitions[apt][proc].add(f"{base_rwy}R")
        # --- Fim Mapeamento ---


        # --- Processamento da Busca e Geração de Resultados ---
        for row in data_to_search: # Iterar sobre os dados filtrados (ou não)
            airport = row.get('airport_identifier')
            waypoint = row.get('waypoint_identifier')
            proc = row.get('procedure_identifier')
            # Guardar a transição ORIGINAL da linha, crucial para buscar a distância
            original_transition = row.get('transition_identifier')
            seqno = row.get('seqno') # Obter o seqno da linha atual

            # Validar dados essenciais da linha
            if not all([airport, waypoint, proc, original_transition]) or seqno is None:
                 continue

            # Pular se o waypoint não corresponder ao termo de busca
            if search_text not in waypoint:
                continue

            # Verificar se temos mapeamento de pistas para este aeroporto/procedimento
            if airport not in airport_runway_transitions or proc not in airport_runway_transitions[airport]:
                 continue # Não há pistas mapeadas para este procedimento

            # Obter o nome longo pré-processado
            long_proc = all_long_procs.get(proc, proc) # Usa ID se não encontrado

            # === BUSCAR DISTÂNCIA CUMULATIVA ===
            distance_nm_str = "N/A" # Valor padrão
            # Chave para buscar no cache de distâncias (usa a transição original)
            distance_key = (airport, proc, original_transition)
            # Obter o dicionário de distâncias cumulativas para esta transição
            cumulative_distances = self.procedure_distances.get(distance_key)

            if isinstance(cumulative_distances, dict) and "error" not in cumulative_distances:
                # Buscar a distância CUMULATIVA específica para o SEQNO atual
                cumulative_dist_value = cumulative_distances.get(seqno)
                if cumulative_dist_value is not None:
                    try:
                        # Formatar para 1 casa decimal
                        distance_nm_str = f"{float(cumulative_dist_value):.1f}"
                    except (ValueError, TypeError):
                        distance_nm_str = "Err" # Indicar erro de formatação
            elif isinstance(cumulative_distances, dict) and "error" in cumulative_distances:
                 distance_nm_str = "Calc Err" # Indicar erro no cálculo
            # ====================================

            # Determinar quais pistas exibir para este waypoint/procedimento
            relevant_runways = airport_runway_transitions[airport][proc]

            for runway_id in sorted(list(relevant_runways)): # Iterar sobre as pistas aplicáveis (10L, 10R, ALL, etc.)
                # Aplicar filtro de pista do usuário, se houver para este aeroporto
                user_runway_filter = self.runway_filters.get(airport)
                if user_runway_filter:
                    # Se temos filtro, permitir apenas 'ALL' ou pistas que estão no filtro
                     if runway_id != "ALL" and runway_id not in user_runway_filter:
                         continue # Pula esta combinação pista/waypoint

                # Construir o nome completo (NAME) - lógica refinada
                # Usar o nome longo do procedimento
                if runway_id != "ALL":
                    full_name = f"{long_proc} {runway_id}" # Ex: VUPOG 3A 15L ou RNAV (GPS) X RWY 10 10
                else:
                    full_name = f"{long_proc} ALL" # Ex: VUPOG 3A ALL

                # Chave para evitar duplicatas na *exibição* final
                # (APT, Pista Exibida, Proc ID, Waypoint ID)
                display_key = (airport, runway_id, proc, waypoint)

                if display_key not in seen_display_entries:
                    seen_display_entries.add(display_key)
                    result_entry = {
                        "APT": airport,
                        "RWY": runway_id, # Pista que será exibida
                        "WPT": waypoint,
                        "DIST": distance_nm_str, # Distância CUMULATIVA até este seqno
                        "NAME": full_name
                    }
                    # Adiciona a chave específica do tipo (SID/STAR) com o nome longo
                    result_entry["SID" if procedure_type == "sids" else "STAR"] = long_proc
                    results.append(result_entry)
        # --- Fim Processamento ---


        # Ordenar resultados finais (ordenação aprimorada)
        def sort_key(item):
            apt = item.get('APT', '')
            rwy = item.get('RWY', '')
            proc_name = item.get('SID', item.get('STAR', ''))
            wpt = item.get('WPT', '')

            # Tentar extrair número da pista para ordenação numérica
            rwy_num_str = ''.join(filter(str.isdigit, rwy))
            rwy_num = int(rwy_num_str) if rwy_num_str else 999 # 999 para 'ALL' ou sem número
            rwy_suffix = rwy[len(rwy_num_str):] if rwy_num_str else rwy # L, C, R, ALL

            return (apt, rwy_num, rwy_suffix, proc_name, wpt)

        results.sort(key=sort_key)
        return results


    def closeEvent(self, event):
        """Garante fechamento da âncora e conexão DB ao fechar a janela."""
        # Fechar âncora
        if self.anchor_button:
            try:
                self.anchor_button.close()
            except Exception as e:
                print(f"Erro ao fechar âncora: {e}")
            self.anchor_button = None

        # Fechar conexão com o banco de dados
        if self.conn:
             try:
                 self.conn.close()
                 print("Conexão com o banco de dados fechada.")
             except sqlite3.Error as e:
                 print(f"Erro ao fechar banco de dados: {e}")
             self.conn = None # Definir como None após fechar

        super().closeEvent(event) # Chamar implementação da classe pai

    def find_latest_database(self):
        """Encontra o arquivo .s3db mais recente no diretório do programa."""
        try:
             # Determina o diretório do script (funciona para executável e script)
             if getattr(sys, 'frozen', False):
                 # Se rodando como executável (PyInstaller)
                 program_dir = os.path.dirname(sys.executable)
             else:
                 # Se rodando como script Python
                 program_dir = os.path.dirname(os.path.abspath(__file__))

             s3db_files = []
             for f in os.listdir(program_dir):
                 if f.endswith('.s3db'):
                      full_path = os.path.join(program_dir, f)
                      if os.path.isfile(full_path):
                           s3db_files.append(full_path)


             if not s3db_files:
                 return None

             # Ordenar por data de modificação, mais recente primeiro
             s3db_files.sort(key=lambda f: os.path.getmtime(f), reverse=True)
             print(f"Banco de dados encontrado: {s3db_files[0]}")
             return s3db_files[0]
        except FileNotFoundError:
             print(f"Diretório do programa não encontrado: {program_dir}")
             return None
        except Exception as e:
             print(f"Erro ao buscar banco de dados: {e}")
             return None


# Bloco principal de execução
if __name__ == "__main__":
    # Importar QAbstractItemView (necessário para SelectionBehavior)
    from PyQt6.QtWidgets import QAbstractItemView

    app = QApplication(sys.argv)
    window = AirportWaypointFinder()
    window.show()
    sys.exit(app.exec())
